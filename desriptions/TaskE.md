В этой версии вам понадобится добавить в транспортный справочник функционал маршрутизации, реализованный с помощью предоставленных нами библиотек.
Изменения формата ввода
Новая секция — routing_settings

Во входной JSON добавляется ключ "routing_settings", значением которого является словарь с двумя ключами:

    "bus_wait_time" — время ожидания автобуса на остановке (в минутах). Считайте, что когда бы человек ни пришёл на остановку и какой бы ни была эта остановка, он будет ждать любой автобус в точности указанное количество минут. Значение — целое число от 1 до 1000.
    "bus_velocity" — скорость автобуса (в км/ч). Считайте, что скорость любого автобуса постоянна и в точности равна указанному числу. Время стоянки на остановках не учитывается, время разгона и торможения — тоже. Значение — вещественное число от 1 до 1000.

Пример 

"routing_settings": {
  "bus_wait_time": 6,
  "bus_velocity": 40
}

Данная конфигурация задаёт время ожидания равным 6 минутам и скорость автобусов равной 40 километрам в час.
Новый тип запросов к базе — Route

В список stat_requests добавляются элементы с "type": "Route" — это запросы на построение маршрута между двумя остановками. Помимо стандартных свойств "id" и "type", они содержат ещё два:

    "from" — остановка, в которой нужно начать маршрут.
    "to" — остановка, в которой нужно закончить маршрут.

Оба значения — названия существующих в базе остановок (однако, возможно, не принадлежащих ни одному автобусному маршруту).

Пример 

{
  "type": "Route",
  "from": "Biryulyovo Zapadnoye",
  "to": "Universam",
  "id": 4
}

Данный запрос означает построение маршрута от остановки «Biryulyovo Zapadnoye» до остановки «Universam».

На маршруте человек может использовать несколько автобусов, и даже один автобус несколько раз — если на некоторых участках он делает большой крюк и проще срезать на другом автобусе.

Маршрут должен быть наиболее оптимален по времени. Если маршрутов с минимально возможным суммарным временем несколько, допускается вывести любой из них: тестирующая система проверяет лишь совпадение времени маршрута с оптимальным и корректность самого маршрута.

При прохождении маршрута время расходуется на два типа активностей:

    Ожидание автобуса. Всегда длится bus_wait_time минут.
    Поездка на автобусе. Всегда длится ровно такое количество времени, которое требуется для преодоления данного расстояния со скоростью bus_velocity. Расстояние между остановками вычисляется по дорогам, то есть с помощью road_distances.

Ходить пешком, выпрыгивать из автобуса между остановками и использовать другие виды транспорта запрещается. На конечных остановках все автобусы высаживают пассажиров и уезжают в парк. Даже если человек едет на кольцевом ("is_roundtrip": true) маршруте и хочет проехать мимо конечной, он будет вынужден выйти и подождать тот же самый автобус ровно bus_wait_time минут. Этот и другие случаи разобраны в примерах.

Ответ на запрос Route устроен следующим образом:

{
    "request_id": <id запроса>,
    "total_time": <суммарное время>,
    "items": [
        <элементы маршрута>
    ]
}

total_time — суммарное время в минутах, требуемое для прохождения маршрута, выведенное в виде вещественного числа.

items — список элементов маршрута, каждый из которых описывает непрерывную активность пассажира, требующую временных затрат. А именно, элементы маршрута бывают двух типов.

Wait — подождать нужное количество минут (в нашем случае — всегда bus_wait_time) на указанной остановке:

{
    "type": "Wait",
    "stop_name": "Biryulyovo",
    "time": 6
}

Bus — проехать span_count остановок (перегонов между остановками) на автобусе bus, потратив указанное количество минут:

{
    "type": "Bus",
    "bus": "297",
    "span_count": 2,
    "time": 5.235
}

В случае отсутствия маршрута между указанными остановками выведите результат в следующем формате:

{
    "request_id": <id запроса>,
    "error_message": "not found"
}

Реализация

Задача поиска оптимального маршрута данного вида сводится к задаче поиска кратчайшего пути во взвешенном ориентированном графе  <"https://yandex.by/search/?text=взвешенный ориентированный граф">.

Мы предоставляем вам две небольшие библиотеки:

    graph.h — класс, реализующий взвешенный ориентированный граф.
    router.h — класс, реализующий поиск кратчайшего пути во взвешенном ориентированном графе.

В отличие от парсера JSON в предыдущей версии задачи, эти библиотеки не нуждаются в модификации. С другой стороны, вы имеете право не использовать их вовсе или модифицировать произвольным образом.

Моделируя ситуации из реальной жизни разработчиков, обе эти библиотеки предоставляются без документации, но с самодокументируемым кодом: интерфейсы представленных классов легко читаются по заголовкам публичных методов.

Про эти классы дополнительно известно следующее:

    Вершины и рёбра графа нумеруются автоинкрементно беззнаковыми целыми числами, хранящимися в типах VertexId и EdgeId: вершины нумеруются от 0 до количества вершин минус один в соответствии с пользовательской логикой, а номер очередного ребра выдаётся методом AddEdge, равен нулю для первого вызова метода и при каждом следующем вызове увеличивается на единицу.
    Память, необходимая для хранения графа, линейна относительно суммы количеств вершин и рёбер.
    Конструктор и деструктор графа имеют линейную сложность, а остальные методы константны или амортизированно константны.
    Маршрутизатор (класс Router) требует квадратичного относительно количества вершин объёма памяти, не считая памяти, требуемой для хранения кэша маршрутов.
    Конструктор маршрутизатора имеет сложность O(V³+E), где V — количество вершин графа, E — количество рёбер.
    Маршрутизатор не работает с графами, имеющими рёбра отрицательного веса.
    Построение маршрута на готовом маршрутизаторе линейно относительно количества рёбер в маршруте. Таким образом, основная нагрузка построения оптимальных путей ложится на конструктор.

Вам необходимо:

    самостоятельно разобраться с понятиями графов и путями в них;
    придумать, как по транспортному справочнику построить граф, путь наименьшего веса в котором соответствует оптимальному маршруту на автобусах, предварительно определившись, что в этом графе будет являться вершинами, а что — рёбрами;
    написать код построения графа и описания маршрута по пути, полученному от маршрутизатора.

Ограничения

В этой и последующих версиях и количество остановок, и количество автобусов не превышает 100.

Ограничение по времени — 3 секунды на тест, по памяти — 512 МБ

В реальном маршрутизаторе время на предварительную подготовку данных вполне могло бы занимать минуты, что позволило бы увеличить это ограничение.
